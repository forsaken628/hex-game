!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.Honeycomb={})}(this,function(t){"use strict";"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var n,r=(function(t,n){t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var e=n.length;e--;)t["is"+n[e]]=function(t){return function(n){return r.call(n)===t}}(n[e]);return t}()}(n={exports:{}},n.exports),n.exports),e=r.isObject,i=r.isNumber,o=r.isArray,s=r.isString;function u(t,n){return n+t*(1&n)>>1}function c(t,n){return(t%n+n)%n}function a(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===n&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function f(t,n){return i(t)||i(n)?i(t)?i(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const h=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],l=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],d={x:1e-6,y:1e-6},x=Math.sqrt(3);function p(){return{x:this.x,y:this.y}}function y(){return{q:this.q,r:this.r,s:this.s}}function b({q:t,r:n}){let r,e;return this.isPointy()?(r=t+u(this.offset,n),e=n):(r=t,e=n+u(this.offset,t)),{x:r,y:e}}function g(){return"pointy"===this.orientation.toLowerCase()}function q(){return"flat"===this.orientation.toLowerCase()}function P(){return 2*this.size}function m(){return x/2*this.oppositeCornerDistance()}function H(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function v(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function w(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function C(){return this.add(d)}function O(){return`${this.x},${this.y}`}var S=function(t,n){var r={};for(var e in t)n.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(r[e]=t[e]);return r},E=function(){return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return function(t,n){var r=[],e=!0,i=!1,o=void 0;try{for(var s,u=t[Symbol.iterator]();!(e=(s=u.next()).done)&&(r.push(s.value),!n||r.length!==n);e=!0);}catch(t){i=!0,o=t}finally{try{!e&&u.return&&u.return()}finally{if(i)throw o}}return r}(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();const j={thirdCoordinate:function(t,n){return-t-n}};function M(t){return i(t)?this[t]:this[this.indexOf(t)]}function N(t,n){const r=t.distance(n),e=1/Math.max(r,1);let i=[];for(let o=0;o<=r;o++){const r=t.nudge().lerp(n.nudge(),e*o).round();i.push(this.get(r))}return i}function T({ensureXY:t}){const n={add:function({Point:t}){return function(n,r){let e;var i=t(n,r);return e=i.x,r=i.y,t(this.x+e,this.y+r)}}({Point:r}),subtract:function({Point:t}){return function(n,r){let e;var i=t(n,r);return e=i.x,r=i.y,t(this.x-e,this.y-r)}}({Point:r}),multiply:function({Point:t}){return function(n,r){let e;var i=t(n,r);return e=i.x,r=i.y,t(this.x*e,this.y*r)}}({Point:r}),divide:function({Point:t}){return function(n,r){let e;var i=t(n,r);return e=i.x,r=i.y,t(this.x/e,this.y/r)}}({Point:r})};function r(r,s){let u;return u=i(r)?t(r,s):o(r)?t(...r):e(r)?t(r.x,r.y):t(0),Object.assign(Object.create(n),u)}return r}const D=T({ensureXY:f});class $ extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const r=this.length;let e=Number(n);for(t=D(t),e=Math.max(e>=0?e:r+e,0);e<r;e++)if(this[e].equals(t))return e;return-1}lastIndexOf(t,n=this.length-1){const r=this.length;let e=Number(n);for(t=D(t),e=e>=0?Math.min(e,r-1):r+e;e>=0;e--)if(this[e].equals(t))return e;return-1}push(...t){return super.push(...t.filter($.isValidHex))}splice(t,n,...r){return null==n?super.splice(t):super.splice(t,n,...r.filter($.isValidHex))}unshift(...t){return super.unshift(...t.filter($.isValidHex))}}const G=T({ensureXY:f}),W=function({ensureXY:t,Point:n}){return function(r={}){const s=function({Point:t}){return function(n,r){let e,i,o;var s=t(n,r);return e=s.x,r=s.y,this.isPointy()?(i=e-u(this.offset,r),o=r):(i=e,o=r-u(this.offset,e)),{q:i,r:o,s:-i-o}}}({Point:n}),c={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:function({Hex:t,Point:n}){return function(r){var e=n(r);const i=e.x,o=e.y;return t(this.x+i,this.y+o,Object.assign({},this))}}({Hex:f,Point:n}),cartesian:p,cartesianToCube:s,center:function({Point:t}){return function(){var n=this.origin;const r=n.x,e=n.y;return t(this.width()/2-r,this.height()/2-e)}}({Point:n}),coordinates:p,corners:function({Point:t}){return function(){const n=this.width(),r=this.height();var e=this.origin;const i=e.x,o=e.y;return this.isPointy()?[t(n-i,.25*r-o),t(n-i,.75*r-o),t(.5*n-i,r-o),t(0-i,.75*r-o),t(0-i,.25*r-o),t(.5*n-i,0-o)]:[t(n-i,.5*r-o),t(.75*n-i,r-o),t(.25*n-i,r-o),t(0-i,.5*r-o),t(.25*n-i,0-o),t(.75*n-i,0-o)]}}({Point:n}),cube:y,cubeToCartesian:b,distance:w,equals:function({Point:t}){return function(n){var r=t(n);const e=r.x,i=r.y;return this.x===e&&this.y===i}}({Point:n}),fromPoint:function({Point:t,Hex:n}){return function(r,e){const i=this.size;let o,s,u;var c=t(r,e).subtract(this.center());return o=c.x,e=c.y,this.isPointy()?(s=(o*x/3-e/3)/i,u=2*e/3/i):(s=2*o/3/i,u=(-o/3+x/3*e)/i),n({q:s,r:u,s:-s-u}).round()}}({Point:n,Hex:f}),height:v,isFlat:q,isPointy:g,lerp:function({Hex:t}){return function(n,r){const e=this.q*(1-r)+n.q*r,i=this.r*(1-r)+n.r*r;return t(Object.assign({},this,{q:e,r:i,s:-e-i}))}}({Hex:f}),nudge:C,oppositeCornerDistance:P,oppositeSideDistance:m,round:function({Hex:t}){return function(){let n=this.q,r=this.r,e=this.s,i=Math.round(n),o=Math.round(r),s=Math.round(e);const u=Math.abs(n-i),c=Math.abs(r-o),a=Math.abs(e-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,t(Object.assign({},this,{q:i,r:o,s:s}))}}({Hex:f}),set:function({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}({Hex:f}),subtract:function({Hex:t,Point:n}){return function(r){var e=n(r);const i=e.x,o=e.y;return t(this.x-i,this.y-o,Object.assign({},this))}}({Hex:f,Point:n}),toCartesian:b,toCube:s,toPoint:function({Point:t}){return function(){const n=this.q,r=this.r,e=this.size;let i,o;return this.isPointy()?(i=e*x*(n+r/2),o=3*e/2*r):(i=3*e/2*n,o=e*x*(r+n/2)),t(i,o)}}({Point:n}),toString:O,width:H},a=Object.assign(c,r);function f(n,r,s={}){let u;if(e(n)){let t=n.q,e=n.r,o=n.s,f=S(n,["q","r","s"]);if(i(t)||i(e)||i(o)){if(t+e+o!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${e}, s: ${o}, sum: ${t+e+o}.`);var c=a.cubeToCartesian({q:t,r:e,s:o});u=c.x,r=c.y}else u=n.x,r=n.y;s=f}else if(o(n)){var f=E(n,2);u=f[0],r=f[1],s={}}else u=n;return Object.assign(Object.create(a),Object.assign(s,t(u,r)))}return a.origin=n(a.origin),Object.assign(f,j),f}}({ensureXY:f,Point:G}),V=function({extendHex:t,Grid:n,Point:r}){const e=n.isValidHex;return function(f=t()){function d(t,...r){return o(t)?r=t:r.unshift(t),new n(...r.filter(e))}return Object.assign(d,{Hex:f,isValidHex:e,pointToHex:function({Hex:t}){return function(n,r){return t().fromPoint(n,r)}}({Point:r,Hex:f}),parallelogram:function({Grid:t,Hex:n}){return function({width:r,height:e,start:i,direction:o=1,onCreate:s=(()=>{})}){i=n(i);var u=E({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],3);const c=u[0],a=u[1],f=u[2],h=new t;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const e=n(i.cubeToCartesian({[c]:t+i[c],[a]:r+i[a],[f]:-t-r+i[f]}));s(e,h),h.push(e)}return h}}({Grid:n,Hex:f}),triangle:function({Grid:t,Hex:n}){return function({size:r,start:e,direction:i=1,onCreate:o=(()=>{})}){e=n(e);var s={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}}[i];const u=s.rStart,c=s.rEnd,a=new t;for(let t=0;t<r;t++)for(let r=u(t);r<c(t);r++){const i=n(e.cubeToCartesian({q:t+e.q,r:r+e.r,s:-t-r+e.s}));o(i,a),a.push(i)}return a}}({Grid:n,Hex:f}),hexagon:function({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const o=new t;for(let t=-r;t<=r;t++){const s=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=s;r<=u;r++){const s=n(e.cubeToCartesian({q:t+e.q,r:r+e.r,s:-t-r+e.s}));i(s,o),o.push(s)}}return o}}({Grid:n,Hex:f}),rectangle:function({Grid:t,Hex:n,compassToNumberDirection:r,signedModulo:e}){return function({width:i,height:o,start:c,direction:a=(n().isPointy()?0:1),onCreate:f=(()=>{})}){c=n(c),s(a)&&(a=r(a,c.orientation)),(a<0||a>5)&&(a=e(a,6));var h=E([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],3);const l=h[0],d=h[1],x=h[2];var p=c.isPointy()?[i,o]:[o,i],y=E(p,2);const b=y[0],g=y[1],q=new t;for(let t=0;t<g;t++){const r=u(c.offset,t);for(let e=-r;e<b-r;e++){const r=n(c.cubeToCartesian({[l]:e+c[l],[d]:t+c[d],[x]:-e-t+c[x]}));f(r,q),q.push(r)}}return q}}({Grid:n,Hex:f,compassToNumberDirection:a,signedModulo:c})}),Object.assign(n.prototype,{get:M,hexesBetween:N,neighborsOf:function({isValidHex:t,signedModulo:n,compassToNumberDirection:r}){return function(e,i="all",o=!1){if(!t(e))throw new Error(`Invalid hex: ${e}.`);const u=o?l:h;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(t=>{s(t)&&(t=r(t,e.orientation)),(t<0||t>5)&&(t=n(t,6));var i=u[t];const o=i.q,c=i.r;return this.get(e.cubeToCartesian({q:e.q+o,r:e.r+c}))}).filter(Boolean)}}({isValidHex:e,signedModulo:c,compassToNumberDirection:a}),set:function({isValidHex:t}){return function(n,r){if(!t(r))return this;const e=i(n)?n:this.indexOf(n);return e<0?this.push(r):this[e]=r,this}}({isValidHex:e})}),d}}({extendHex:W,Grid:$,Point:G});t.extendHex=W,t.defineGrid=V,t.Point=G,Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=honeycomb.min.js.map
