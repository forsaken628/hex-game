{"version":3,"file":"honeycomb.min.js","sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/constants.js","../src/hex/prototype.js","../src/hex/index.js","../src/hex/statics.js","../src/grid/prototype.js","../src/point/index.js","../src/point/prototype.js","../src/grid/class.js","../src/honeycomb.js","../src/grid/index.js","../src/grid/statics.js"],"sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n    return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n    return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n    if (!/^(N|S)?(E|W)?$/i.test(value)) {\n        throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n    }\n\n    orientation = orientation.toLowerCase()\n    value = value.toUpperCase()\n\n    if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n    }\n    if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n    }\n\n    /**\n     * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n     * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n     * and flat hexes don't have a west and east compass direction.\n     *\n     * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n     * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n     *\n     * @typedef {string} COMPASS_DIRECTION\n     *\n     * @readonly\n     * @enum {COMPASS_DIRECTION}\n     *\n     * @property {COMPASS_DIRECTION} E  → east\n     * @property {COMPASS_DIRECTION} SE ↘ southeast\n     * @property {COMPASS_DIRECTION} S  ↓ south\n     * @property {COMPASS_DIRECTION} SW ↙ southwest\n     * @property {COMPASS_DIRECTION} W  ← west\n     * @property {COMPASS_DIRECTION} NW ↖ northwest\n     * @property {COMPASS_DIRECTION} N  ↑ north\n     * @property {COMPASS_DIRECTION} NE ↗ northeast\n     */\n    return {\n        pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n        flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 }\n    }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n    if (!isNumber(x) && !isNumber(y)) {\n        x = y = 0\n    } else if (!isNumber(x)) {\n        x = y\n    } else if (!isNumber(y)) {\n        y = x\n    }\n\n    return { x, y }\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n    { q: 1, r: 0 },\n    { q: 0, r: 1 },\n    { q: -1, r: 1 },\n    { q: -1, r: 0 },\n    { q: 0, r: -1 },\n    { q: 1, r: -1 }\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n    { q: 2, r: -1 },\n    { q: 1, r: 1 },\n    { q: -1, r: 2 },\n    { q: -2, r: 1 },\n    { q: -1, r: -1 },\n    { q: 1, r: -2 }\n]\n\nexport const EPSILON = { x: 1e-6, y: 1e-6 }\n","import { EPSILON } from './constants'\nimport { offsetFromZero } from '../utils'\n\nconst sqrt3 = Math.sqrt(3)\n\nexport function setFactory({ Hex }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n     * @returns {hex}           Itself with the passed parameters merged into it.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n     * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n     * hex === updatedHex                                   // true: hex is updated in-place\n     */\n    return function set(...args) {\n        return Object.assign(this, Hex(...args))\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n    return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n    return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n    let x, y\n\n    if (this.isPointy()) {\n        x = q + offsetFromZero(this.offset, r)\n        y = r\n    } else {\n        x = q\n        y = r + offsetFromZero(this.offset, q)\n    }\n\n    return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     *\n     * @todo make this a static (and instance?) method\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * const Point = Honeycomb.Point\n     *\n     * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n     */\n    return function cartesianToCube(pointOrX, y) {\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y))\n\n        if (this.isPointy()) {\n            q = x - offsetFromZero(this.offset, y)\n            r = y\n        } else {\n            q = x\n            r = y - offsetFromZero(this.offset, x)\n        }\n\n        return { q, r, s: -q - r }\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy ⬢ orientation.\n */\nexport function isPointy() {\n    return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat ⬣ orientation.\n */\nexport function isFlat() {\n    return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite corners of a hex.\n */\nexport function oppositeCornerDistance() {\n    return this.size * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite sides of a hex.\n */\nexport function oppositeSideDistance() {\n    return sqrt3 / 2 * this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n    return this.isPointy() ?\n        this.oppositeSideDistance() :\n        this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n    return this.isPointy() ?\n        this.oppositeCornerDistance() :\n        this.oppositeSideDistance()\n}\n\nexport function cornersFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point[]}\n     * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n     * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n     *\n     * @example\n     * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n     * const Hex1 = Honeycomb.extendHex({ size: 30 })\n     * Hex1().corners() // [\n     *                  //    { x: 51.96152422706631, y: 15 },\n     *                  //    { x: 51.96152422706631, y: 45 },\n     *                  //    { x: 25.980762113533157, y: 60 },\n     *                  //    { x: 0, y: 45 },\n     *                  //    { x: 0, y: 15 },\n     *                  //    { x: 25.980762113533157, y: 0 }\n     *                  // ]\n     *\n     * // set the origin to a hex's center\n     * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n     * Hex2().corners() // [\n     *                  //    { x: 25.980762113533157, y: -15 },\n     *                  //    { x: 25.980762113533157, y: 15 },\n     *                  //    { x: 0, y: 30 },\n     *                  //    { x: -25.980762113533157, y: 15 },\n     *                  //    { x: -25.980762113533157, y: -15 },\n     *                  //    { x: 0, y: -30 }\n     *                  // ]\n     */\n    return function corners() {\n        const width = this.width()\n        const height = this.height()\n        const { x, y } = this.origin\n\n        if (this.isPointy()) {\n            return [\n                Point(width - x, height * 0.25 - y),\n                Point(width - x, height * 0.75 - y),\n                Point(width * 0.5 - x, height - y),\n                Point(0 - x, height * 0.75 - y),\n                Point(0 - x, height * 0.25 - y),\n                Point(width * 0.5 - x, 0 - y)\n            ]\n        } else {\n            return [\n                Point(width - x, height * 0.5 - y),\n                Point(width * 0.75 - x, height - y),\n                Point(width * 0.25 - x, height - y),\n                Point(0 - x, height * 0.5 - y),\n                Point(width * 0.25 - x, 0 - y),\n                Point(width * 0.75 - x, 0 - y)\n            ]\n        }\n    }\n}\n\nexport function centerFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n     * Note that the default origin is the top left corner, so the default center is\n     * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n     *\n     * @example\n     * const Hex1 = Honeycomb.extendHex({ size: 10 })\n     * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n     *\n     * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n     * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n     */\n    return function center() {\n        const { x, y } = this.origin\n        return Point(this.width() / 2 - x, this.height() / 2 - y)\n    }\n}\n\nexport function toPointFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} The hex's origin point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 30 })\n     * Hex().toPoint()          // { x: 0, y: 0 }\n     * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n     */\n    return function toPoint() {\n        const { q, r, size } = this\n        let x, y\n\n        if (this.isPointy()) {\n            x = size * sqrt3 * (q + r / 2)\n            y = size * 3/2 * r\n        } else {\n            x = size * 3/2 * q\n            y = size * sqrt3 * (r + q / 2)\n        }\n\n        return Point(x, y)\n    }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n    /**\n     * Returns a hex from the passed {@link point}.\n     *\n     * @memberof Hex\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Point = Honeycomb.Point\n     * const hex = Hex()\n     *\n     * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n     * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n     * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function fromPoint(pointOrX, y) {\n        const { size } = this\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n        if (this.isPointy()) {\n            q = (x * sqrt3 / 3 - y / 3) / size\n            r = y * 2 / 3 / size\n        } else {\n            q = x * 2 / 3 / size\n            r = (-x / 3 + sqrt3 / 3 * y) / size\n        }\n\n        return Hex({ q, r, s: -q - r }).round()\n    }\n}\n\nexport function addFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to add.\n     *\n     * @param {point} point The hex (or point) that will be added to the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n     *                      Any custom properties are copied.\n     */\n    return function add(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x + x, this.y + y, {...this})\n    }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to subtract.\n     *\n     * @param {point} point The hex (or point) that will be subtracted from the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n     *                      Any custom properties are copied.\n     */\n    return function subtract(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x - x, this.y - y, {...this})\n    }\n}\n\nexport function equalsFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n     * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n     */\n    return function equals(point) {\n        const { x, y } = Point(point)\n        return this.x === x && this.y === y\n    }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n    return Math.max(\n        Math.abs(this.q - hex.q),\n        Math.abs(this.r - hex.r),\n        Math.abs(this.s - hex.s)\n    )\n}\n\nexport function roundFactory({ Hex }) {\n    /**\n     * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n     *\n     * @memberof Hex#\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n     *\n     * @returns {hex}   A *new* hex with rounded coordinates.\n     *                  Any custom properties are copied.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n     */\n    return function round() {\n        let { q, r, s } = this\n        let roundedQ = Math.round(q)\n        let roundedR = Math.round(r)\n        let roundedS = Math.round(s)\n        const diffQ = Math.abs(q - roundedQ)\n        const diffR = Math.abs(r - roundedR)\n        const diffS = Math.abs(s - roundedS)\n\n        if (diffQ > diffR && diffQ > diffS) {\n            roundedQ = -roundedR - roundedS\n        } else if (diffR > diffS) {\n            roundedR = -roundedQ - roundedS\n        } else {\n            roundedS = -roundedQ - roundedR\n        }\n\n        return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n    }\n}\n\nexport function lerpFactory({ Hex }) {\n    /**\n     * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n     * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n     *\n     * @memberof Hex#\n     *\n     * @param   {hex} hex   The other hex (cannot be a {@link point}).\n     * @param   {number} t  A \"parameter\" between 0 and 1.\n     *\n     * @returns {hex}       A new hex (likely with floating point coordinates).\n     *                      Any custom properties are copied.\n     */\n    return function lerp(hex, t) {\n        const q = this.q * (1 - t) + hex.q * t\n        const r = this.r * (1 - t) + hex.r * t\n        return Hex({ ...this, q, r, s: -q - r })\n    }\n}\n\n/**\n * @memberof Hex#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n *                  Useful for interpolating in a consistent direction.\n */\nexport function nudge() {\n    return this.add(EPSILON)\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n    return `${this.x},${this.y}`\n}\n","import { isObject, isNumber, isArray } from 'axis.js'\n\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport const staticMethods = {\n    thirdCoordinate: statics.thirdCoordinate\n}\n\nexport default function extendHexFactory({ ensureXY, Point }) {\n    /**\n     * @function extendHex\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create custom hexes by extending the default Hex prototype.\n     *\n     * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n     * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n     *\n     * @todo validate orientation, size, origin\n     * @todo warn when properties are overriden\n     *\n     * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n     *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n     *\n     * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({\n     *     size: 50,\n     *     orientation: 'flat',\n     *     customProperty: `I'm custom 😃`,\n     *     customMethod() {\n     *         return `${this.customProperty} and called from a custom method 😎`\n     *     }\n     * })\n     * const hex = Hex(5, -1)\n     *\n     * hex.coordinates()    // { x: 5, y: -1 }\n     * hex.size             // 50\n     * hex.customProperty   // I'm custom 😃\n     * hex.customMethod()   // I'm custom 😃 and called from a custom method 😎\n     *\n     * // every hex created with Hex() shares these properties:\n     * const hex2 = Hex(3, 0)\n     * hex2.size            // 50\n     * hex2.customProperty  // I'm custom 😃\n     *\n     * // to set properties on individual hexes, pass them to Hex():\n     * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake 😌` })\n     * hex3.instanceProperty    // I'm a unique snowflake 😌\n     */\n    return function extendHex(prototype = {}) {\n        const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n        const defaultPrototype = {\n            /**\n             * Used internally for type checking\n             *\n             * @memberof Hex#\n             * @private\n             */\n            __isHoneycombHex: true,\n            /**\n             * Either ⬢ pointy or ⬣ flat. Defaults to `pointy`.\n             *\n             * @memberof Hex#\n             * @type {string}\n             * @default 'pointy'\n             */\n            orientation: 'pointy',\n            /**\n             * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n             * Can be anything the {@link Honeycomb.Point} factory accepts.\n             * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n             *\n             * @memberof Hex#\n             * @type {point}\n             * @default 0\n             */\n            origin: 0,\n            /**\n             * A hex's radius or the length of any of its sides. Defaults to `1`.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default 1\n             */\n            size: 1,\n            /**\n             * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n             * Defaults to `-1` (odd offset).\n             * See {@link OFFSET} for details.\n             * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default -1\n             * @see OFFSET\n             */\n            offset: -1,\n            /**\n             * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get q() { return this.cartesianToCube(this).q },\n            /**\n             * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get r() { return this.cartesianToCube(this).r },\n            /**\n             * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get s() { return this.cartesianToCube(this).s },\n\n            // methods:\n            add: methods.addFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#coordinates}.\n             * @memberof Hex#\n             * @instance\n             */\n            cartesian: methods.coordinates,\n            cartesianToCube,\n            center: methods.centerFactory({ Point }),\n            coordinates: methods.coordinates,\n            corners: methods.cornersFactory({ Point }),\n            cube: methods.cube,\n            cubeToCartesian: methods.cubeToCartesian,\n            distance: methods.distance,\n            equals: methods.equalsFactory({ Point }),\n            fromPoint: methods.fromPointFactory({ Point, Hex }),\n            height: methods.height,\n            isFlat: methods.isFlat,\n            isPointy: methods.isPointy,\n            lerp: methods.lerpFactory({ Hex }),\n            nudge: methods.nudge,\n            oppositeCornerDistance: methods.oppositeCornerDistance,\n            oppositeSideDistance: methods.oppositeSideDistance,\n            round: methods.roundFactory({ Hex }),\n            set: methods.setFactory({ Hex }),\n            subtract: methods.subtractFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#cubeToCartesian}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCartesian: methods.cubeToCartesian,\n            /**\n             * Alias for {@link Hex#cartesianToCube}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCube: cartesianToCube,\n            toPoint: methods.toPointFactory({ Point }),\n            toString: methods.toString,\n            width: methods.width\n        }\n        const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n        // ensure origin is a point\n        finalPrototype.origin = Point(finalPrototype.origin)\n\n        Object.assign(Hex, staticMethods)\n\n        /**\n         * @function Hex\n         *\n         * @description\n         * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n         *\n         * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n         *\n         * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n         *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n         *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n         *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n         * @param {number} [xOrProps.x=]                    The x coordinate.\n         * @param {number} [xOrProps.y=]                    The y coordinate.\n         * @param {number} [y=]                             The y coordinate.\n         * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n         *\n         * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n         *\n         * @example\n         * const Hex = Honeycomb.extendHex()\n         *\n         * // passing numbers:\n         * Hex()                        // { x: 0, y: 0 }\n         * Hex(1)                       // { x: 1, y: 1 }\n         * Hex(1, 2)                    // { x: 1, y: 2 }\n         *\n         * // passing an object with cartesian coordinates:\n         * Hex({})                      // { x: 0, y: 0 }\n         * Hex({ x: 1 })                // { x: 1, y: 1 }\n         * Hex({ y: 2 })                // { x: 2, y: 2 }\n         * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n         *\n         * // passing an object with cube coordinates:\n         * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n         * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n         *\n         * // passing an array:\n         * Hex([])                      // { x: 0, y: 0 }\n         * Hex([1])                     // { x: 1, y: 1 }\n         * Hex([1, 2])                  // { x: 1, y: 2 }\n         *\n         * // custom properties:\n         * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n         * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n         *\n         * // cloning a hex:\n         * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n         * const clone = Hex(someHex)   // { x: 4, y: -2 }\n         * someHex === clone            // false\n         */\n        function Hex(xOrProps, y, customProps = {}) {\n            let x\n\n            if (isObject(xOrProps)) {\n                let { q, r, s, ...rest } = xOrProps\n\n                if (isNumber(q) || isNumber(r) || isNumber(s)) {\n                    if (q + r + s !== 0) {\n                        throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n                    }\n\n                    ({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n                } else {\n                    ({ x, y } = xOrProps)\n                }\n\n                customProps = rest\n            } else if (isArray(xOrProps)) {\n                [x, y] = xOrProps\n                // ignore all arguments except xOrProps\n                customProps = {}\n            } else {\n                x = xOrProps\n            }\n\n            /**\n             * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n             *\n             * @typedef {Object} hex\n             * @property {number} x Cartesian x coordinate.\n             * @property {number} y Cartesian y coordinate.\n             */\n            return Object.assign(\n                // the prototype has to be attached here, else Grid's shape methods break 🙁\n                Object.create(finalPrototype),\n                Object.assign(customProps, ensureXY(x, y))\n            )\n        }\n\n        return Hex\n    }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n    return -firstCoordinate - secondCoordinate\n}\n","import { isString, isNumber } from 'axis.js'\n\nimport { DIRECTION_COORDINATES, DIAGONAL_DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n    if (isNumber(keyOrPoint)) {\n        return this[keyOrPoint]\n    } else {\n        return this[this.indexOf(keyOrPoint)]\n    }\n}\n\nexport function setFactory({ isValidHex }) {\n    /**\n     * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n     *\n     * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n     * If the new hex is invalid, nothing changes.\n     *\n     * @memberof Grid#\n     * @instance\n     *\n     * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n     * @param {hex} newHex                  The replacing hex.\n     *\n     * @returns {grid}                      Itself.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n     *\n     * // replace a hex:\n     * grid.set(0, Hex(1, 1))\n     * grid                         // [ { x: 1, y: 1 } ]\n     * // the target hex can also be a point:\n     * grid.set([1, 1], Hex(2, 2))\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // invalid replace values are ignored:\n     * grid.set(0, 'invalid')\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // when the target hex isn't present in the grid, the replacing hex is added instead:\n     * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n     * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n     */\n    return function set(keyOrPoint, newHex) {\n        if (!isValidHex(newHex)) {\n            return this\n        }\n\n        const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n        if (index < 0) {\n            this.push(newHex)\n        } else {\n            this[index] = newHex\n        }\n\n        return this\n    }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n    const distance = firstHex.distance(lastHex)\n    const step = 1.0 / Math.max(distance, 1)\n    let hexes = []\n\n    for (let i = 0; i <= distance; i++) {\n        const hex = firstHex.nudge().lerp(lastHex.nudge(), step * i).round()\n        hexes.push(this.get(hex))\n    }\n\n    return hexes\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n     *\n     * @param {hex} hex\n     * A hex to get 1 or more neighbors from.\n     * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n     * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n     * @param {boolean} [diagonal=false]\n     * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n     *\n     * @returns {hex[]}\n     * An array of 0 up to 6 neighboring hexes. Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     * @throws {Error} When the direction is invalid for the hex.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n     * const grid = Grid.hexagon({ radius: 1 })\n     *\n     * // all neighbors:\n     * grid.neighborsOf(Hex())          // [\n     *                                  //    { x: 1, y: 0 },\n     *                                  //    { x: 0, y: 1 },\n     *                                  //    { x: -1, y: 1 },\n     *                                  //    { x: -1, y: 0 },\n     *                                  //    { x: -1, y: -1 },\n     *                                  //    { x: 0, y: -1 },\n     *                                  // ]\n     * // specific neighbor:\n     * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n     * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n     *\n     * // multiple neighbors:\n     * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     *\n     * grid.neighborsOf(Hex(), [1, 2])          // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     * // diagonal neighbor:\n     * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.neighborsOf(Hex(-1, -1), 'NW')      // []\n     */\n    return function neighborsOf(hex, directions = 'all', diagonal = false) {\n        if (!isValidHex(hex)) {\n            throw new Error(`Invalid hex: ${hex}.`)\n        }\n\n        const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n        if (directions === 'all') {\n            directions = [0, 1, 2, 3, 4, 5]\n        }\n\n        return directions = []\n            // ensure directions is an array\n            .concat(directions)\n            .map(direction => {\n                // todo: move this to a util, also grid/statics.js#277\n                if (isString(direction)) {\n                    direction = compassToNumberDirection(direction, hex.orientation)\n                }\n\n                if (direction < 0 || direction > 5) {\n                    direction = signedModulo(direction, 6)\n                }\n\n                const { q, r } = coordinates[direction]\n                return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n            })\n            .filter(Boolean)\n    }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n    const prototype = {\n        add: methods.addFactory({ Point }),\n        subtract: methods.subtractFactory({ Point }),\n        multiply: methods.multiplyFactory({ Point }),\n        divide: methods.divideFactory({ Point })\n    }\n\n    /**\n     * Factory function for creating two-dimensional points.\n     *\n     * @function Point\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}                             A point.\n     *\n     * @example\n     * const Point = Honeycomb.Point\n     *\n     * Point()                  // { x: 0, y: 0 }\n     * Point(1)                 // { x: 1, y: 1 }\n     * Point(1, 2)              // { x: 1, y: 2 }\n     *\n     * Point([])                // { x: 0, y: 0 }\n     * Point([1])               // { x: 1, y: 1 }\n     * Point([1, 2])            // { x: 1, y: 2 }\n     *\n     * Point({})                // { x: 0, y: 0 }\n     * Point({ x: 1 })          // { x: 1, y: 1 }\n     * Point({ y: 2 })          // { x: 2, y: 2 }\n     * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n     */\n    function Point(pointOrX, y) {\n        let coordinates\n        /**\n         * An object with just an `x` and a `y` property.\n         *\n         * Create your own:\n         * ```javascript\n         * const point = { x: 1, y: 2 }\n         * ```\n         *\n         * Or use the included {@link Point} factory:\n         * ```javascript\n         * const point = Honeycomb.Point(1, 2)\n         * ```\n         *\n         * @typedef {Object} point\n         * @property {number} x (horizontal) x coordinate\n         * @property {number} y (vertical) y coordinate\n         */\n\n        if (isNumber(pointOrX)) {\n            coordinates = ensureXY(pointOrX, y)\n        } else if (isArray(pointOrX)) {\n            coordinates = ensureXY(...pointOrX)\n        } else if (isObject(pointOrX)) {\n            coordinates = ensureXY(pointOrX.x, pointOrX.y)\n        } else {\n            coordinates = ensureXY(0)\n        }\n\n        return Object.assign(\n            Object.create(prototype),\n            coordinates\n        )\n    }\n\n    return Point\n}\n","export function addFactory({ Point }) {\n    /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n    return function add(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x + x, this.y + y)\n    }\n}\n\nexport function subtractFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The difference between the passed point's coordinates and the current point's.\n     */\n    return function subtract(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x - x, this.y - y)\n    }\n}\n\nexport function multiplyFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n     */\n    return function multiply(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x * x, this.y * y)\n    }\n}\n\nexport function divideFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The division of the current point's coordinates and the passed point's.\n     */\n    return function divide(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x / x, this.y / y)\n    }\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n    /**\n     * @private\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    static isValidHex(value) {\n        return (value || {}).__isHoneycombHex === true\n    }\n\n    /**\n     * @memberof Grid#\n     * @override\n     * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n     *\n     * @returns {TypeError} An error.\n     */\n    fill() {\n        throw new TypeError('Grid.prototype.fill is not implemented')\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n     * but searches the passed hex (which can also be a {@link point}.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *\n     * @returns {boolean}               Whether the hex is included in the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n     *\n     * grid.includes(Hex(0))        // true\n     * grid.includes([0, 0])        // true\n     * grid.includes(Hex(0), 1)     // false\n     * grid.includes(Hex(5, 7))     // false\n     */\n    includes(point, fromIndex = 0) {\n        return !!(this.indexOf(point, fromIndex) + 1)\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *                                  If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.indexOf(Hex(0))     // 0\n     * grid.indexOf([0, 0])     // 0\n     * grid.indexOf(Hex(0), 1)  // 2\n     * grid.indexOf(Hex(5, 7))  // -1\n     */\n    indexOf(point, fromIndex = 0) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = Math.max(i >= 0 ? i : length + i, 0)\n\n        for (i; i < length; i++) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n     * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point                 The coordinates to search for.\n     * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n     *                                      If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.lastIndexOf(Hex(0))     // 2\n     * grid.lastIndexOf([0, 0])     // 2\n     * grid.lastIndexOf(Hex(0), 1)  // 0\n     * grid.lastIndexOf(Hex(5, 7))  // -1\n     */\n    lastIndexOf(point, fromIndex = this.length - 1) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n        for (i; i >= 0; i--) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.push(Hex(1))            // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.push('invalid')         // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     */\n    push(...hexes) {\n        return super.push(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {number} start                        Index at which to start changing the grid.\n     * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n     * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n     *\n     * @returns {hex[]}                             A grid with the deleted hexes (if any).\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid.rectangle({ width: 2, height: 1 })\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 0, y: 1 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     *\n     * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n     *\n     * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n     * grid\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 2, y: 2 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     */\n    splice(start, deleteCount, ...hexes) {\n        // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n        // this is not according to spec: it should delete all hexes (starting from `start`)\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        if (deleteCount == null) {\n            return super.splice(start)\n        }\n\n        return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.unshift(Hex(1))         // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     *\n     * grid.unshift('invalid')      // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     */\n    unshift(...hexes) {\n        return super.unshift(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat|Array#concat}.\n     * @memberof Grid#\n     * @method concat\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin|Array#copyWithin}.\n     * @memberof Grid#\n     * @method copyWithin\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries|Array#entries}.\n     * @memberof Grid#\n     * @method entries\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|Array#every}.\n     * @memberof Grid#\n     * @method every\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|Array#filter}.\n     * @memberof Grid#\n     * @method filter\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|Array#find}.\n     * @memberof Grid#\n     * @method find\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex|Array#findIndex}.\n     * @memberof Grid#\n     * @method findIndex\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|Array#forEach}.\n     * @memberof Grid#\n     * @method forEach\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join|Array#join}.\n     * @memberof Grid#\n     * @method join\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys|Array#keys}.\n     * @memberof Grid#\n     * @method keys\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|Array#map}.\n     * @memberof Grid#\n     * @method map\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop|Array#pop}.\n     * @memberof Grid#\n     * @method pop\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|Array#reduce}.\n     * @memberof Grid#\n     * @method reduce\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight|Array#reduceRight}.\n     * @memberof Grid#\n     * @method reduceRight\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse|Array#reverse}.\n     * @memberof Grid#\n     * @method reverse\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift|Array#shift}.\n     * @memberof Grid#\n     * @method shift\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|Array#some}.\n     * @memberof Grid#\n     * @method some\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort|Array#sort}.\n     * @memberof Grid#\n     * @method sort\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString|Array#toLocaleString}.\n     * @memberof Grid#\n     * @method toLocaleString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString|Array#toString}.\n     * @memberof Grid#\n     * @method toString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values|Array#values}.\n     * @memberof Grid#\n     * @method values\n     * @instance\n     */\n}\n","import { ensureXY } from './utils'\nimport extendHexFactory from './hex'\nimport defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport PointFactory from './point'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport {\n    extendHex,\n    defineGrid,\n    Point\n}\n","import { isArray } from 'axis.js'\n\nimport { signedModulo, compassToNumberDirection } from '../utils'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n    const { isValidHex } = Grid\n\n    /**\n     * @function defineGrid\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n     *\n     * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n     *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n     *\n     * @returns {Grid}                          A Grid factory.\n     *\n     * @example\n     * // create a Grid factory that uses the default Hex Factory:\n     * const Grid = Honeycomb.defineGrid()\n     * const hex = Grid.Hex()\n     * hex.size     // 1\n     *\n     * // create your own Hex factory\n     * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '🤓' })\n     * // …and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n     * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n     * const customHex = CustomGrid.Hex()\n     * hex.size     // 10\n     * hex.custom   // 🤓\n     */\n    return function defineGrid(Hex = extendHex()) {\n        // static properties\n        Object.assign(GridFactory, {\n            /**\n             * The {@link Hex} factory the Grid factory was created with.\n             * @memberof Grid\n             * @static\n             * @function\n             */\n            // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n            // it could cause this:\n            // function methodThatBindsThis() {\n            //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n            // }\n            // which is caused by the following line:\n            Hex,\n\n            // methods\n            /**\n             * @memberof Grid\n             * @static\n             * @method\n             *\n             * @param {*} value     Any value.\n             * @returns {boolean}   Whether the passed value is a valid hex.\n             */\n            isValidHex,\n            pointToHex: statics.pointToHexFactory({ Point, Hex }),\n            parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n            triangle: statics.triangleFactory({ Grid, Hex }),\n            hexagon: statics.hexagonFactory({ Grid, Hex }),\n            rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo })\n        })\n\n        // prototype properties\n        Object.assign(\n            Grid.prototype,\n            {\n                // methods\n                get: methods.get,\n                hexesBetween: methods.hexesBetween,\n                neighborsOf: methods.neighborsOfFactory({\n                    isValidHex,\n                    signedModulo,\n                    compassToNumberDirection\n                }),\n                set: methods.setFactory({ isValidHex })\n            }\n        )\n\n        /**\n         * @function Grid\n         *\n         * @description\n         * A function to create hex {@link grid}s and perform various operations on them.\n         *\n         * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n         * It can also be called with 1 or more hexes or an array of hexes to construct/clone a {@link grid} containing those hexes.\n         *\n         * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n         *\n         * @param {(hex[]|hex)} [arrayOrHex]    An array or a hex. Any invalid hexes are filtered out.\n         * @param {...hex} [hexes]              More hexes. Any invalid hexes are filtered out.\n         *\n         * @returns {grid}                      A grid instance containing only valid hexes.\n         *\n         * @example\n         * const Grid = Honeycomb.defineGrid()\n         * // the Hex factory used by the Grid to produce hexes is available as a property\n         * const Hex = Grid.Hex\n         *\n         * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         *\n         * // invalid hexes are filtered out:\n         * Grid('no hex', { x: 3, y: -1 })  // []\n         * Grid(['no hex', Hex(1, -1)])     // [{ x: 1, y: -1 }]\n         *\n         * // clone a grid:\n         * const grid = Grid(Hex(), Hex(1), Hex(2))\n         * const clonedGrid = Grid(grid)    // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n         * grid === clonedGrid              // false\n         */\n        function GridFactory(arrayOrHex, ...hexes) {\n            if (isArray(arrayOrHex)) {\n                hexes = arrayOrHex\n            } else {\n                hexes.unshift(arrayOrHex)\n            }\n\n            /**\n             * @typedef {Object} grid\n             * @extends Array\n             *\n             * @property {number} length    Amount of hexes in the grid.\n             */\n            return new Grid(...hexes.filter(isValidHex))\n        }\n\n        return GridFactory\n    }\n}\n","import { isString } from 'axis.js'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n    /**\n     * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link Hex#fromPoint}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const Point = Honeycomb.Point\n     *\n     * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n     * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n     * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function pointToHex(pointOrX, y) {\n        return Hex().fromPoint(pointOrX, y)\n    }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) ▱.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n     */\n    return function parallelogram({\n        width,\n        height,\n        start,\n        direction = 1,\n        /**\n         * Callback of a {@link Grid} shape method.\n         * Gets called for each hex that's about to be added to the grid.\n         *\n         * @callback onCreate\n         * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n         * @param {grid} grid   The grid (for as far as it's created).\n         * @returns {void}      Nothing.\n         */\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: ['q', 'r', 's'],\n            3: ['r', 's', 'q'],\n            5: ['s', 'q', 'r']\n        }\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let first = 0; first < width; first++) {\n            for (let second = 0; second < height; second++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) △.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.size                 The side length (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n     * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a triangle arrangement.\n     */\n    return function triangle({\n        size,\n        start,\n        direction = 1,\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: {\n                rStart: () => 0,\n                rEnd: q => size - q\n            },\n            5: {\n                rStart: q => size - q,\n                rEnd: () => size + 1\n            }\n        }\n        const { rStart, rEnd } = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let q = 0; q < size; q++) {\n            for (let r = rStart(q); r < rEnd(q); r++) {\n                const hex = Hex(start.cubeToCartesian({\n                    q: q + start.q,\n                    r: r + start.r,\n                    s: -q - r + start.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) ⬡.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n     * @param {hex} [options.center=Hex(0)]         The center hex.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n     */\n    return function hexagon({\n        radius,\n        center,\n        onCreate = () => { }\n    }) {\n        center = Hex(center)\n\n        const grid = new Grid()\n\n        for (let q = -radius; q <= radius; q++) {\n            const startR = Math.max(-radius, -q - radius)\n            const endR = Math.min(radius, -q + radius)\n\n            for (let r = startR; r <= endR; r++) {\n                const hex = Hex(center.cubeToCartesian({\n                    q: q + center.q,\n                    r: r + center.r,\n                    s: -q - r + center.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n    /**\n     * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) ▭.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n     * The direction (from the start hex) in which to create the shape.\n     * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n     * Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n     */\n    return function rectangle({\n        width,\n        height,\n        start,\n        direction = Hex().isPointy() ? 0 : 1, // E or S\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n\n        if (isString(direction)) {\n            direction = compassToNumberDirection(direction, start.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n            direction = signedModulo(direction, 6)\n        }\n\n        const DIRECTIONS = [\n            ['q', 'r', 's'],\n            ['r', 'q', 's'],\n            ['r', 's', 'q'],\n            ['s', 'r', 'q'],\n            ['s', 'q', 'r'],\n            ['q', 's', 'r']\n        ]\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n        const grid = new Grid()\n\n        for (let second = 0; second < secondStop; second++) {\n            const secondOffset = offsetFromZero(start.offset, second)\n\n            for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n"],"names":["module","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","factory","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","E","SE","SW","W","NW","NE","S","N","ensureXY","x","y","isNumber","DIRECTION_COORDINATES","q","r","DIAGONAL_DIRECTION_COORDINATES","EPSILON","sqrt3","Math","sqrt","coordinates","cube","s","cubeToCartesian","isPointy","isFlat","oppositeCornerDistance","size","oppositeSideDistance","width","height","hex","max","abs","nudge","add","staticMethods","firstCoordinate","secondCoordinate","get","keyOrPoint","indexOf","hexesBetween","firstHex","lastHex","step","hexes","lerp","round","push","PointFactory","Point","pointOrX","methods","isArray","isObject","assign","create","Grid","Array","__isHoneycombHex","TypeError","point","fromIndex","Number","equals","min","super","filter","isValidHex","start","deleteCount","splice","unshift","extendHex","cartesianToCube","defaultPrototype","Hex","origin","subtract","center","t","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","args","finalPrototype","xOrProps","customProps","rest","extendHexFactory","defineGrid","GridFactory","arrayOrHex","fromPoint","statics","direction","onCreate","thirdCoordinate","grid","first","second","rStart","rEnd","radius","startR","endR","isString","firstStop","secondStop","secondOffset","directions","diagonal","concat","map","Boolean","newHex","index","defineGridFactory"],"mappings":"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"}